---
interface Props {
  imageSlug: string;
}

const { imageSlug } = Astro.props;
---

<div id="scene-container" data-image-slug={imageSlug}></div>
<script>
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

const sceneContainer = document.getElementById('scene-container');
const imageSlug = sceneContainer.dataset.imageSlug;
console.log('Image slug:', imageSlug);
// Set up scene
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x333333, 1); // Light gray background for visibility
sceneContainer.appendChild(renderer.domElement);

// Add OrbitControls
const controls = new OrbitControls(camera, renderer.domElement);

// Position camera
camera.position.set(0, 0, 5);
controls.update();

// Create a texture loader
const textureLoader = new THREE.TextureLoader();

// Load the model
const loader = new GLTFLoader();
loader.load(
  '/models/test-cube-03.glb',
  (gltf) => {
    console.log('GLTF model loaded successfully');
    scene.add(gltf.scene);

    // Log material information and apply texture
    gltf.scene.traverse((child) => {
      if (child.isMesh) {
        console.log(`Mesh name: ${child.name}`);
        
        // Ensure the material is MeshStandardMaterial
        if (!(child.material instanceof THREE.MeshStandardMaterial)) {
          child.material = new THREE.MeshStandardMaterial({
            color: child.material.color,
            name: child.material.name
          });
        }

        console.log(`  Material name: ${child.material.name}`);
        
        // Apply texture to specific material (e.g., 'testFront')
        if (child.material.name === 'testFront') {
          console.log('  Applying texture to this material');
          textureLoader.load(`/images/${imageSlug}`, (texture) => {
            texture.flipY = false; // This flips the texture vertically

    
            child.material.map = texture;
            // child.material.color.setHex(0xFFFFFF); // Set to white
            // child.material.transparent = false;
            // child.material.opacity = 1;
            // child.material.depthWrite = true;
            // child.material.needsUpdate = true;
          });
        }
        
        // Ensure the material responds to light
        // child.material.roughness = 0.7;
        // child.material.metalness = 0.2;
      }
    });
  },
  (xhr) => {
    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
  },
  (error) => {
    console.error('An error happened', error);
  }
);

// Add lights to the scene
const ambientLight = new THREE.AmbientLight(0xffffff, 0.95);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.95);
directionalLight.position.set(5, 5, 5);
scene.add(directionalLight);

const pointLight = new THREE.PointLight(0xffffff, 0.85);
pointLight.position.set(-5, -5, -5);
scene.add(pointLight);

// Render loop
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();

// Handle window resizing
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
<style>
#scene-container {
  width: 100%;
  height: 100vh;
}
</style>
