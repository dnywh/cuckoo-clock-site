---
interface Props {
  imageSlug: string;
}

const { imageSlug } = Astro.props;
---

<div id="scene-container" data-image-slug={imageSlug}></div>
<script>
  import * as THREE from "three";
  import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";

  const sceneContainer = document.getElementById("scene-container");
  const imageSlug = sceneContainer.dataset.imageSlug;
  console.log("Image slug:", imageSlug);

  // Set up scene
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000); // Initial aspect ratio set to 1
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setClearColor(0x333333, 1); // Light gray background for visibility
  sceneContainer.appendChild(renderer.domElement);

  // Function to update sizes
  function updateSizes() {
    const width = sceneContainer.clientWidth;
    const height = sceneContainer.clientHeight;

    camera.aspect = width / height;
    camera.updateProjectionMatrix();

    renderer.setSize(width, height);
  }

  // Initial size update
  updateSizes();

  // Position camera
  camera.position.set(0, -100, 100);
  camera.lookAt(0, 0, 0);

  // Create a texture loader
  const textureLoader = new THREE.TextureLoader();

  // Load the model
  const loader = new GLTFLoader();
  loader.load(
    "/models/test-08.glb",
    (gltf) => {
      console.log("GLTF model loaded successfully");
      scene.add(gltf.scene);

      // Log material information and apply texture
      gltf.scene.traverse((child) => {
        if (child.isMesh) {
          console.log(`Mesh name: ${child.name}`);

          // Ensure the material is MeshStandardMaterial
          if (!(child.material instanceof THREE.MeshStandardMaterial)) {
            child.material = new THREE.MeshStandardMaterial({
              color: child.material.color,
              name: child.material.name,
            });
          }

          console.log(`  Material name: ${child.material.name}`);

          // Apply texture to specific material (e.g., 'testFront')
          if (child.material.name === "screen") {
            console.log("  Applying texture to this material");
            textureLoader.load(`/images/${imageSlug}`, (texture) => {
              texture.flipY = false; // This flips the texture vertically
              child.material.map = texture;
              child.material.needsUpdate = true;
            });
          }
        }
      });
    },
    (xhr) => {
      console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
    },
    (error) => {
      console.error("An error happened", error);
    }
  );

  // Add lights to the scene
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.95);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.95);
  directionalLight.position.set(5, 5, 5);
  scene.add(directionalLight);

  const pointLight = new THREE.PointLight(0xffffff, 0.85);
  pointLight.position.set(-5, -5, -5);
  scene.add(pointLight);

  // Render loop
  function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  animate();

  // Handle window resizing
  window.addEventListener("resize", updateSizes);

  // Handle scrolling
  window.addEventListener("scroll", () => {
    const scrollPercentage =
      window.scrollY /
      (document.documentElement.scrollHeight - window.innerHeight);
    const rotationAngle = (scrollPercentage * Math.PI) / 6; // Rotate up to 30° (180°/6) degrees in the opposite direction
    scene.rotation.x = -rotationAngle;
  });

  // Trigger a resize event after a short delay to ensure proper initial sizing
  setTimeout(() => {
    window.dispatchEvent(new Event("resize"));
  }, 100);
</script>
<style>
  #scene-container {
    width: 100%;
    height: 80vh;
  }
</style>
